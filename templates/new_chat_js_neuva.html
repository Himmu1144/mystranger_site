{% include 'friend/snippets/send_friend_request.html' %}
{% include 'friend/snippets/cancel_friend_request.html' %}
<script type="text/javascript">

    const video = document.getElementById('remote');
    const loadingSpinner = document.querySelector('.loading-spinner');

    video.addEventListener('loadedmetadata', () => {
        if (video.getAttribute('src')) {
            loadingSpinner.style.display = 'none';
        }
    }); 

    {% comment %} const our_video = document.getElementById("ours");{% endcomment %}
    const remote_video = document.getElementById("remote"); 

    let peerConnection;
    let localStream;
    let remoteStream;

    // Create an array to store ICE candidates
    let iceCandidates = [];
    // let stream;
    // let rtcpeerconnection;
    // {% comment %} const constraints = {
    //     'video': true,
    //    'audio': false
    //  } {% endcomment %}

    // Contains the stun server URL we will be using.
    let servers = {
    iceServers:[
        {
            urls:['stun:stun1.1.google.com:19302', 'stun:stun2.1.google.com:19302']
        }
    ]
}
    // let iceServers = {
    //     iceServers: [
    //         { urls: "stun:stun.services.mozilla.com" },
    //         { urls: "stun:stun.l.google.com:19302" },
    //     ],
    // };

    // {% comment %} navigator.mediaDevices.getUserMedia(constraints).then(s => {
    //      stream = s;
    //     our_video.srcObject = s;
    //     our_video.onloadedmetadata = () => {
    //         our_video.play()
    //     }
    // }) {% endcomment %}

    // let init = async () => { 
    //     local_video = document.getElementById("ours");
        
    //     localStream = await navigator.mediaDevices.getUserMedia({video:true, audio:true}).then(stream =>{
    //         localStream = stream;
    //         local_video.srcObject = localStream;
    //         local_video.muted = true;
    //         console.log('Both audio and video access granted');
    //     }).catch(error =>{
    //         localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false }).then(stream =>{
    //         localStream = stream;
    //         local_video.srcObject = localStream;
    //         local_video.muted = true;
    //         console.log('Video access granted, but audio access denied');
    //         document.getElementById('audio-error').style.display = 'block'
    //         }).catch(error =>{
    //             console.error('Error with both video & audio access:', error);
    //         })
    //     })
        
    // } 

    
    let init = async () => { 
        try {
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            console.log('Both audio and video access granted');
        } catch (error) {
            console.error('Error with audio and video access:', error);
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                console.log('Video access granted, but audio access denied');
                document.getElementById('audio-error').style.display = 'block'
                // You can display a message to the user indicating that audio is not available.
            } catch (error) {
                console.error('Error with video access:', error);
                document.getElementById('video-error').style.display = 'block'
                // Handle the case where both audio and video access failed.
                // You may want to inform the user and take appropriate action.
            }
        }

        if (localStream) {
            document.getElementById("ours").srcObject = localStream;
            document.getElementById("ours").muted = true

            // Now you can use localStream for your WebRTC connection.
        }
    };

    init()

    let createPeerConnection = async (groupName) => {

        
        peerConnection = new RTCPeerConnection(servers)

        remoteStream = new MediaStream()
        document.getElementById("remote").srcObject = remoteStream;

        localStream.getTracks().forEach((track) => {
        peerConnection.addTrack(track, localStream)
    })

        peerConnection.ontrack = async (event) => {
            event.streams[0].getTracks().forEach((track) => {
                remoteStream.addTrack(track)
            })
        }

        // peerConnection.onicecandidate = async (event) => {
        //     if(event.candidate){
        //         // document.getElementById(sdpType).value = JSON.stringify(peerConnection.localDescription)
        //         // client.sendMessageToPeer({text:JSON.stringify({'type':'candidate', 'candidate':event.candidate})}, MemberId)
        //         // await peerConnection.setLocalDescription(peerConnection.localDescription);
        //         console.log('ice sent by - ', window.user)
        //         chatSocket.send(
        //             JSON.stringify({
        //                 command: "candidate",
        //                 candidate: event.candidate,
        //                 iscreated: window.user,
        //                 group: groupName,
        //             })
        //         );
        //     } 
        // }

    }

    

    let createOffer = async (groupName) => {

        if (!localStream) {
            await init();  // Ensure localStream is initialized if not already
        }

        try {


            createPeerConnection(groupName)
            
            let offer = await peerConnection.createOffer()
            await peerConnection.setLocalDescription(offer)
            console.log('This is my fuckin offer -- ', offer)

            // now gets all the ice candidates and when they are all gathered then send the offer

            peerConnection.onicecandidate = async (event) => {
                if(event.candidate){
                    
                    console.log('ice candidate generated by - ', window.user)
                     // Collect ICE candidates
                    iceCandidates.push(event.candidate);
                    
                } else{

                    chatSocket.send(
                        JSON.stringify({
                            command: "offer",
                            offer: peerConnection.localDescription,
                            icecandidates: iceCandidates,
                            group: groupName,
                        })
                    ); 

                    console.log(offer)
                    console.log('ice candidates - ',iceCandidates)

                }
            }


        } catch (error) {
                console.error('Error during offer creation:', error);
            }

    }



    let createAnswer = async (offer, groupName, icecandidatis) => { 

        if (!localStream) {
            await init();  // Ensure localStream is initialized if not already
        }

        try{

            createPeerConnection(groupName)

            console.log('Before setRemoteDescription:', peerConnection.signalingState);
            await peerConnection.setRemoteDescription(offer)
            console.log('###### remote discription set for user2 (offer added) now can add ice on user2 -no ice adding above this for user2.', peerConnection.signalingState)
            

            let answer = await peerConnection.createAnswer()
            await peerConnection.setLocalDescription(answer)
            console.log('This is my fuckin answer ----', answer)

            // Add received ICE candidates to the peerConnection
            if (icecandidatis && icecandidatis.length > 0) {
                icecandidatis.forEach((candidate) => {


                    if (peerConnection.signalingState === "have-remote-offer" || peerConnection.signalingState === "have-local-pranswer") {

                        console.log('#################################################')
                        console.log('yesh adding ice candidates in a valid state - ', peerConnection.signalingState)
                        console.log('#################################################')

                    } else {

                        console.log('#################################################')
                        console.log('The hell, adding ice candidates in an invalid state - ', peerConnection.signalingState)
                        console.log('but somehow still this fucker is working')
                        console.log('#################################################')

                        // console.error('Not in the right signaling state for adding ICE candidate. Current state:', peerConnection.signalingState)
                         }



                    {% comment %} if (peerConnection.signalingState === "have-remote-offer" || peerConnection.signalingState === "have-local-pranswer") { {% endcomment %}
                        const iceCandidate = new RTCIceCandidate(candidate);
                        peerConnection.addIceCandidate(iceCandidate).catch((error) => {
                            console.error('Error adding received ICE candidate:', error);
                        }); 
                        console.log('boom added ice candis - ', peerConnection.signalingState)

                    {% comment %} } else {
                        console.error('Not in the right signaling state for adding ICE candidate. Current state:', peerConnection.signalingState)
                         } {% endcomment %}


                });
            }

            // now gets all the ice candidates and when they are all gathered then send the offer

            peerConnection.onicecandidate = async (event) => {
                if(event.candidate){
                    
                    console.log('ice candidate generated by - ', window.user)
                     // Collect ICE candidates
                    iceCandidates.push(event.candidate);
                    // return;
                } else {

                    chatSocket.send(
                            JSON.stringify({
                                command: "answer",
                                answer: peerConnection.localDescription,
                                icecandidates: iceCandidates,
                                group: groupName,
                            })
                        );

                    console.log(answer)
                    console.log('ice candidates - ',iceCandidates)
                }

            }
            
        } catch (error) {
                console.error('Error during answer creation:', error);
            }

    }

    
let addAnswer = async (answer,icecandidates) => {

    try{
    
        if (peerConnection && !peerConnection.currentRemoteDescription) {
            console.log('Before setRemoteDescription:', peerConnection.signalingState);
            await peerConnection.setRemoteDescription(answer)
            console.log('###### remote discription set for user1 (answer added) now can add ice on user1 -no ice adding above this for user1.',peerConnection.signalingState)


            // Add received ICE candidates to the peerConnection
            if (icecandidates && icecandidates.length > 0) {
                icecandidates.forEach((candidate) => {

                    if (peerConnection.signalingState === "have-remote-offer" || peerConnection.signalingState === "have-local-pranswer") {

                        console.log('#################################################')
                        console.log('yesh adding ice candidates in a valid state - ', peerConnection.signalingState)
                        console.log('#################################################')

                    } else {

                        console.log('#################################################')
                        console.log('The hell, adding ice candidates in an invalid state - ', peerConnection.signalingState)
                        console.log('but somehow still this fucker is working')
                        console.log('#################################################')

                        // console.error('Not in the right signaling state for adding ICE candidate. Current state:', peerConnection.signalingState)
                         }



                     {% comment %} if (peerConnection.signalingState === "have-remote-offer" || peerConnection.signalingState === "have-local-pranswer") { {% endcomment %}
                        const iceCandidate = new RTCIceCandidate(candidate);
                        peerConnection.addIceCandidate(iceCandidate).catch((error) => {
                            console.error('Error adding received ICE candidate:', error);
                        }); 
                        console.log('boom added ice candis - ', peerConnection.signalingState)
                     {% comment %} } else {
                        console.error('Not in the right signaling state for adding ICE candidate. Current state:', peerConnection.signalingState)
                         } {% endcomment %}


                });
            }

            
        }
        // peerConnection.setRemoteDescription(answer)
    
    } catch (error) {
        console.error('Error during adding answer:', error);
    }
}






    

    // Here we are handling the socket connection and also what happens when socket disconnects.
    // -----------------------------------------------------------------------------------------

    console.log("Setting up the WebSocket - ")

    // Correctly decide between ws:// and wss://
    var ws_scheme = window.location.protocol == "https:" ? "wss" : "ws";
    // var ws_path = ws_scheme + '://' + window.location.host + "/chat/"; // development
    var ws_path = ws_scheme + '://' + window.location.host + ":8001/chat/"; // development 

    // console.log("Connecting to " + ws_path);
    chatSocket = new WebSocket(ws_path);

    let commandCount = 0;
    let leaveCount = 0;

    // Handle incoming messages
    chatSocket.onmessage = function (message) {

        // Decode the JSON
        console.log("Got websocket message.");
        var data = JSON.parse(message.data);
        {% comment %} console.log(data) {% endcomment %}

        
        if (data.my_id) {
            // Settting up the self_id so that it can be used further on.
            window.self_id = data.my_id
            console.log('My_Id : ' + window.self_id)
        }

        // seprating code for user1 and user2

        if (data.status_user2) {
            window.user = 'user2'
            console.log("I am gonna receive the offer and create the answer",window.user)
        }
        if (data.status_user1) {
            window.user = 'user1'
            console.log('I am gonna create the offer',window.user)
        }

        if (data.grouped) {

           

            console.log(data)
            commandCount++;

            console.log('The value of grouped count is - ', commandCount)
            if (commandCount === 1){

                statusUpdate(data.response)
                console.log(data.response)
                console.log('group_name : ' + data.grouped)
                window.group_name = data.grouped


                chatSocket.send(JSON.stringify({
                    "command": 'grouped',
                    "group_name": data.grouped,
                }));

                // Enabling the textarea and the send_btn
                document.getElementById('id_chat_message_input').disabled = false;
                document.getElementById('send_button').disabled = false;
                document.getElementById('send_req_btn').disabled = false;
                
                var send_icon = document.getElementById('id_chat_message_submit')
                send_icon.classList.remove("d-none");


                // here user1 is creating the offer

                if (window.user == 'user1') {
                    window.self_name = data.user1_self_name
                    window.stranger = data.random_user_name
                    window.stranger_id = data.random_user_id
                    window.stranger_email = data.random_user_email
                    // createOffer()

                    console.log('creating offer by - ', window.user)
                    createOffer(data.grouped);
                    console.log('offer created')
                }
                else {
                    window.self_name = data.random_user_name
                    window.stranger = data.user1_self_name
                    window.stranger_id = data.user1_self_id
                    window.stranger_email = data.user1_self_email
                }

                const loadingSpinner = document.querySelector('.loading-spinner');
                loadingSpinner.style.display = 'none';

                {% comment %} document.getElementById('strangerName').innerHTML = window.stranger + ' | ' + window.stranger_email {% endcomment %}
                document.getElementById('strangerName').innerHTML = window.stranger
                document.getElementById('report_btn').disabled = false;
                document.getElementById('flag_user_id').value = window.stranger_id;
                document.getElementById('flag_user_name').value = window.stranger;
                {% comment %} document.getElementById('flagged_by').value = window.; {% endcomment %}
                console.log('The strangers id is - ', window.stranger_id)
            } else {
                console.log("This is the second time of grouped message so we will ignore it")
            }

        }

        if (data.isTyping) {
            // Display "user is typing" message
            if (data.id != window.self_id){
            const typingIndicator = document.getElementById('typing');
            typingIndicator.classList.remove("d-none");
    
            // Add a timeout to remove the message after a few seconds
            setTimeout(() => {
                typingIndicator.classList.add("d-none");
            }, 3000); // Remove the message after 1 seconds (adjust as needed)
        }
        } 

        if (data["command"] == "offer") {
            console.log('offer recieved by User2')
            if (window.user == 'user2') {
                console.log('user2 ----------')
                console.log('Got the offer baby')
                // createanswer(data["offer"]);
                createAnswer(data["offer"],data['groupName'],data['icecandidates']);
                console.log('answer created')
            }
        } else if (data["command"] == "answer") {
            console.log('answer received by user1')
            if (window.user == 'user1') {
                console.log('Got the answer baby and added it - ', window.user)
                // rtcpeerconnection.setRemoteDescription(data["answer"]);
                console.log("the real estate - ", peerConnection.signalingState)
                addAnswer(data['answer'],data['icecandidates']);
                console.log("answer set as remote");
                console.log("the real estate - ", peerConnection.signalingState)
            }
        }
        //  else if (data["command"] == "candidate") {
        //     // {% comment %} console.log('ice received in the group -', window.user) {% endcomment %}
        //     if (data["iscreated"] != window.user && peerConnection) {
        //         console.log('ice recieved by user - ', window.user, 'state - ', peerConnection.signalingState)
        //         if (peerConnection.signalingState === "have-remote-offer" || peerConnection.signalingState === "have-local-pranswer") {
        //             // Add ICE candidate
        //             try{
        //             console.log('adding ice to user - ', window.user)
        //             console.log(data.candidate, 'created by - ', data.iscreated)
        //             const IceCandidate = new RTCIceCandidate(data["candidate"]); 
        //             peerConnection.addIceCandidate(IceCandidate);
        //             // peerConnection.addIceCandidate(data["candidate"]);
        //         } catch (error) {
        //             console.error('Error during adding ice candidate:', error);
        //         }
        //         }else {
        //             console.log(data.candidate)
        //             console.log(data)
        //             console.error('Not in the right signaling state for adding ICE candidate. Current state:', peerConnection.signalingState);
        //         }
        //     }
        // }

        if (data.leave) {

            

            leaveCount++;
            console.log('The value of leave count is - ', leaveCount)
            
            if (leaveCount === 1){
                remote_video.srcObject = undefined;
               
                {% comment %} remote_video.style.backgroundColor = 'rgba(64, 64, 64, 0.5)'; {% endcomment %}

                if (window.self_id == data.disconnector) {
                    response = 'You have disconnected.'
                }
                else {
                    response = 'Stranger have disconnected.'
                }

                // if(data.by_skip == 'skip'){
                //     window.by_skip = true
                //     statusUpdate(response)
                // }
                // else {
                //     window.by_skip = false
                // }

                // if (window.by_skip && data.by_skip == 'normal'){
                //     // we don't have to update the satatus
                // }
                // else {
                //     statusUpdate(response)
                // }

                console.log(data.leave)
                statusUpdate(response)

                const loadingSpinner = document.querySelector('.loading-spinner');
                loadingSpinner.style.display = 'none';


                // again disabling the textarea and the send_btn
                document.getElementById('id_chat_message_input').disabled = true;
                document.getElementById('send_button').disabled = true;
                document.getElementById('send_req_btn').disabled = true;

                // hiding the skip button and showing new_chat button instead of that.
                really_btn = document.getElementById('skip_button')
                really_btn.style.display = 'none';
                new_btn = document.getElementById('new_button')
                new_btn.classList.remove("d-none");

                send_icon = document.getElementById('id_chat_message_submit')
                send_icon.classList.add("d-none");
            } else{
                console.log("This is the second time of leave message so we will ignore it")
            }
        }

        // Handle getting a message
        if (data.msg_type == 0) {
            console.log(data);
            appendChatMessage(data, true)
        }

        if (data.test) {
            console.log(data.test)
        }
    }

    // basic event listeners for our websocket
    // ------------------------------------------------------------------------

    chatSocket.addEventListener("open", function (e) {
        console.log("ChatSocket OPEN")
        // join chat room
        if ("{{request.user.is_authenticated}}") {
            chatSocket.send(JSON.stringify({
                "command": "join",
            }));
        }

    })


    chatSocket.onclose = function (e) {
        console.log('Chat socket closed.');

    };

    chatSocket.onOpen = function (e) {
        console.log("ChatSocket onOpen", e)
    }

    chatSocket.onerror = function (e) {
        console.log('ChatSocket error', e)
    }

    if (chatSocket.readyState == WebSocket.OPEN) {
        console.log("ChatSocket OPENN")

    } else if (chatSocket.readyState == WebSocket.CONNECTING) {
        console.log("ChatSocket connecting..")
    }



    // Here we are dealing with submitting our message
    // -----------------------------------------------------------------------------------

    document.getElementById('id_chat_message_input').focus();
    document.getElementById('id_chat_message_input').onkeyup = function (e) {
        if (e.keyCode === 13 && e.shiftKey) {  // enter + return
            // Handled automatically by textarea
        }
        else if (e.keyCode === 13 && !e.shiftKey) { // enter + !return
            document.getElementById('id_chat_message_submit').click();
        }
    };


    document.getElementById('id_chat_message_submit').onclick = function (e) {
        const messageInputDom = document.getElementById('id_chat_message_input');
        const message = messageInputDom.value;
        var trimmedValue = message.trim();
        if (trimmedValue === ''){
            console.log('fucker this is an empty msg....')
        } else{
        chatSocket.send(JSON.stringify({
            "command": "send",
            "message": message,
            "user_id": window.self_id,
            "group_name": window.group_name,
        }));

        messageInputDom.value = '';
    }
    };

    // Here we are writing the code for skip button so that we can skip the chat using the skip button.
    // ------------------------------------------------------------------------------------------------

    document.getElementById('skip_button').onclick = function (e) {
        const skip = document.getElementById('skip').innerHTML;

        if (skip == 'Skip') {
            console.log('skip button is clicked!')
            document.getElementById('skip').innerHTML = 'really?'
        }
        else if (skip == 'really?') {
            console.log('really button is clicked!')
            if (window.group_name) {
                group_name = window.group_name
            }
            else {
                group_name = null
            }
            chatSocket.send(JSON.stringify({
                'command': 'skip',
                'group_name': group_name,
            }));

        }
        else {
            console.log(skip);
            console.log('check it again')
        }
    };

    // typing setup -----

    const inputField = document.getElementById('id_chat_message_input');
    inputField.addEventListener('input', () => {

        // Send a "typing" event to the server using WebSocket
        chatSocket.send(JSON.stringify(
            {
                "command": "typing",
                "group_name": window.group_name,
                "isTyping": true,
                "userName": window.self_name, // Add the username
                "userId": window.self_id, // Add the user's ID 
            }
        ));
    });
    

    var sendFriendRequestBtn = document.getElementById("send_req_btn")
	if (sendFriendRequestBtn != null){
		sendFriendRequestBtn.addEventListener("click", function(){
			sendFriendRequest(window.stranger_id, onFriendRequestSent)
		})
	}

    var cancelFriendRequestBtn = document.getElementById("cancel_req_btn")
	if(cancelFriendRequestBtn != null){
		cancelFriendRequestBtn.addEventListener("click", function(){
			cancelFriendRequest(window.stranger_id, onFriendRequestCancelled)
		})
	}

    // Here when the new button is clicked than simply refresh the page
    // document.getElementById('new_button').onclick = function (e) {
    //     location.reload(true);
    // };
    // Idk why but this is causing trouble



    // Some Functions to make our program effiecient 
    // ------------------------------------------------------------------------

    // status bar to inform the user about it's status 

    function statusUpdate(message) {
        var spinner = document.getElementById("bar")
        spinner.innerHTML = message
    }

    function onFriendRequestSent(){
		var sendFriendRequestBtn = document.getElementById("send_req_btn")
        sendFriendRequestBtn.style.display = "none"

		var cancelFriendRequestBtn = document.getElementById("cancel_req_btn")
        cancelFriendRequestBtn.classList.remove("d-none");
		// though reloding the page is the easiest and most convenient way but we can try to do this without reloading the page
		// if there's a way to do so then that is going to enhance the user experience
	}

    function onFriendRequestCancelled(){

        var cancelFriendRequestBtn = document.getElementById("cancel_req_btn")
        cancelFriendRequestBtn.classList.add("d-none");

		var sendFriendRequestBtn = document.getElementById("send_req_btn")
        sendFriendRequestBtn.style.display = "inline-block"
	}

    // here we are going to write two lengthy functions which are going to add messages to our htnl template

    function appendChatMessage(data, isNewMessage) {
        message = data['message']
        uName = data['id']
        if (uName == window.self_id) {
            var username = 'You :'
            var flex = true
        }
        else {
            var username = window.stranger + ' :'
            var flex = false
        }
        var msg = message + '\n';
        createChatMessageElement(msg, username, isNewMessage, flex)
    }

    function createChatMessageElement(msg, username, isNewMessage, flex) {
        var chatLog = document.getElementById("id_chat_log")

        var newMessageDiv = document.createElement("div")
        newMessageDiv.classList.add("d-flex")
        newMessageDiv.classList.add("flex-row")
        newMessageDiv.classList.add("message-container")

        if (flex){
            newMessageDiv.style.justifyContent = "end";
        } else{
            newMessageDiv.style.justifyContent = "start";
        }

        var div1 = document.createElement("div")
        div1.classList.add("d-flex")
        div1.classList.add("flex-column")
        if (flex){
            div1.classList.add("msg-style")

        }else{
            div1.classList.add("msg-style2")
        }

        var div2 = document.createElement("div")
        div2.classList.add("d-flex")
        div2.classList.add("flex-row")

        var usernameSpan = document.createElement("span")
        usernameSpan.addEventListener("click", function (e) {
            //selectUser(user_id)
        })
        // usernameSpan.classList.add("username-span")
        // usernameSpan.innerHTML = username
        // div2.appendChild(usernameSpan)


        // div1.appendChild(div2)

        var msgP = document.createElement("p")
		msgP.innerHTML = validateText(msg)
        // msgP.innerHTML = msg
        msgP.classList.add("msg-p")
        div1.appendChild(msgP)

        newMessageDiv.appendChild(div1)

        if (isNewMessage) {
            console.log('yup adding below ig')
            chatLog.insertBefore(newMessageDiv, chatLog.firstChild)
        }

    }

    // RTCPR Functions

    // function createOffer() {
    //     rtcpeerconnection = new RTCPeerConnection(iceServers)
    //     rtcpeerconnection.onicecandidate = OnIceCandidateFunc;
    //     rtcpeerconnection.ontrack = OnTrackFunc;
    //     stream.getTracks().forEach((track) => {
    //         rtcpeerconnection.addTrack(track, stream);
    //     });
    //     rtcpeerconnection.createOffer().then((offer) => {
    //         rtcpeerconnection.setLocalDescription(offer);
            // chatSocket.send(
            //     JSON.stringify({
            //         command: "offer",
            //         offer: offer,
            //         group: window.group_name,
            //     })
            // );
    //     });

    // }

    // function OnIceCandidateFunc(e) {
    //     if (e.candidate) {
            // chatSocket.send(
            //     JSON.stringify({
            //         command: "candidate",
            //         candidate: e.candidate,
            //         iscreated: window.user,
            //         group: window.group_name,
            //     })
            // );
    //     }
    // }

    // function OnTrackFunc(e) {
    //     remote_video.srcObject = e.streams[0];
    //     remote_video.onloadedmetadata = () => {
    //         remote_video.play();
    //     };
    // }

    // function createanswer(offer) {
    //     console.log("answer started");
    //     rtcpeerconnection = new RTCPeerConnection(iceServers);
    //     rtcpeerconnection.onicecandidate = OnIceCandidateFunc;
    //     rtcpeerconnection.ontrack = OnTrackFunc;
    //     stream.getTracks().forEach((track) => {
    //         rtcpeerconnection.addTrack(track, stream);
    //     });
    //     rtcpeerconnection.setRemoteDescription(offer);
    //     rtcpeerconnection.createAnswer().then((answer) => {
    //         rtcpeerconnection.setLocalDescription(answer);
            // chatSocket.send(
            //     JSON.stringify({
            //         command: "answer",
            //         answer: answer,
            //         group: window.group_name,
            //     })
            // );
    //     });
    // }


</script>